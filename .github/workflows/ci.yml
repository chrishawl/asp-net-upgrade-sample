name: CI Build and Test

on:
  push:
    branches: [ main, develop, "copilot/*" ]
  pull_request:
    branches: [ main, develop ]

env:
  SOLUTION_FILE: aspnet-upgrade-sample.sln
  BUILD_CONFIGURATION: Release

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  build-and-test:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Setup NuGet
      uses: NuGet/setup-nuget@v2.0.0
      with:
        nuget-version: 'latest'

    - name: Verify .NET Framework Installation
      run: |
        Write-Host "=== .NET Framework Version Information ==="
        # Check available .NET Framework versions
        $dotnetVersions = Get-ChildItem "HKLM:SOFTWARE\Microsoft\NET Framework Setup\NDP" -Recurse |
          Get-ItemProperty -Name version, release -EA 0 |
          Where-Object { $_.PSChildName -match '^(?!S)\p{Nd}' } |
          Select-Object PSChildName, version, release
        
        Write-Host "Installed .NET Framework versions:"
        $dotnetVersions | Format-Table
        
        # Check MSBuild version
        Write-Host "MSBuild version:"
        msbuild -version
        
        Write-Host "Environment ready for .NET Framework 4.7.2 build"
      shell: powershell

    - name: Restore NuGet packages
      id: restore
      run: |
        try {
          Write-Host "Restoring NuGet packages..."
          nuget restore ${{ env.SOLUTION_FILE }}
          Write-Host "NuGet packages restored successfully!"
        } catch {
          Write-Host "NuGet restore failed with error: $_"
          echo "restore_failed=true" >> $env:GITHUB_OUTPUT
          echo "restore_error=$_" >> $env:GITHUB_OUTPUT
          throw $_
        }
      shell: powershell

    - name: Build solution
      id: build
      run: |
        try {
          Write-Host "Building solution..."
          msbuild ${{ env.SOLUTION_FILE }} /p:Configuration=${{ env.BUILD_CONFIGURATION }} /p:Platform="Any CPU" /verbosity:normal /flp:logfile=build.log;verbosity=diagnostic
          Write-Host "Build completed successfully!"
        } catch {
          Write-Host "Build failed with error: $_"
          echo "build_failed=true" >> $env:GITHUB_OUTPUT
          echo "build_error=$_" >> $env:GITHUB_OUTPUT
          throw $_
        }
      shell: powershell

    - name: Create test results directory
      run: |
        if (!(Test-Path "TestResults")) { New-Item -ItemType Directory -Path "TestResults" }
      shell: powershell

    - name: Run xUnit tests
      id: test
      run: |
        try {
          $testDll = "tests\MVCRandomAnswerGenerator.Framework.Tests\bin\${{ env.BUILD_CONFIGURATION }}\MVCRandomAnswerGenerator.Framework.Tests.dll"
          $xunitRunner = ".\packages\xunit.runner.console.2.4.1\tools\net452\xunit.console.exe"
          
          # Verify test assembly exists
          if (!(Test-Path $testDll)) {
            $error = "Test assembly not found at: $testDll"
            Write-Error $error
            echo "test_failed=true" >> $env:GITHUB_OUTPUT
            echo "test_error=$error" >> $env:GITHUB_OUTPUT
            exit 1
          }
          
          # Verify xUnit runner exists
          if (!(Test-Path $xunitRunner)) {
            $error = "xUnit console runner not found at: $xunitRunner"
            Write-Error $error
            echo "test_failed=true" >> $env:GITHUB_OUTPUT
            echo "test_error=$error" >> $env:GITHUB_OUTPUT
            exit 1
          }
          
          Write-Host "Running tests..."
          & $xunitRunner $testDll -xml TestResults\test-results.xml
          
          if ($LASTEXITCODE -ne 0) {
            $error = "Tests failed with exit code $LASTEXITCODE"
            Write-Error $error
            echo "test_failed=true" >> $env:GITHUB_OUTPUT
            echo "test_error=$error" >> $env:GITHUB_OUTPUT
            exit $LASTEXITCODE
          } else {
            Write-Host "All tests passed successfully!"
          }
        } catch {
          Write-Host "Test execution failed with error: $_"
          echo "test_failed=true" >> $env:GITHUB_OUTPUT
          echo "test_error=$_" >> $env:GITHUB_OUTPUT
          throw $_
        }
      shell: powershell

    - name: Publish test results
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: .NET Framework Tests
        path: TestResults/test-results.xml
        reporter: java-junit
        fail-on-error: true

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: TestResults/

    - name: Comment on PR with failure details
      if: failure() && github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          let comment = '## ðŸš¨ CI Build/Test Failure\n\n';
          comment += `**Workflow Run:** [${context.runNumber}](${context.payload.repository.html_url}/actions/runs/${context.runId})\n`;
          comment += `**Commit:** ${context.sha.substring(0, 7)}\n`;
          comment += `**Branch:** ${context.ref}\n\n`;
          
          // Check for different types of failures
          const restoreFailed = '${{ steps.restore.outputs.restore_failed }}' === 'true';
          const buildFailed = '${{ steps.build.outputs.build_failed }}' === 'true';
          const testFailed = '${{ steps.test.outputs.test_failed }}' === 'true';
          
          // Use variables to safely handle error messages that may contain special characters
          const restoreError = `${{ steps.restore.outputs.restore_error }}`;
          const buildError = `${{ steps.build.outputs.build_error }}`;
          const testError = `${{ steps.test.outputs.test_error }}`;
          
          if (restoreFailed) {
            comment += '### ðŸ“¦ NuGet Restore Failure\n';
            comment += '```\n';
            comment += restoreError + '\n';
            comment += '```\n\n';
          }
          
          if (buildFailed) {
            comment += '### ðŸ”¨ Build Failure\n';
            comment += '```\n';
            comment += buildError + '\n';
            comment += '```\n\n';
            
            // Try to read build log if it exists
            try {
              if (fs.existsSync('build.log')) {
                const buildLog = fs.readFileSync('build.log', 'utf8');
                const lastLines = buildLog.split('\n').slice(-20).join('\n');
                comment += '**Last 20 lines of build log:**\n';
                comment += '```\n';
                comment += lastLines;
                comment += '\n```\n\n';
              }
            } catch (e) {
              console.log('Could not read build log:', e.message);
            }
          }
          
          if (testFailed) {
            comment += '### ðŸ§ª Test Failure\n';
            comment += '```\n';
            comment += testError + '\n';
            comment += '```\n\n';
            
            // Try to read test results if they exist
            try {
              if (fs.existsSync('TestResults/test-results.xml')) {
                comment += '**Test results file generated - check the uploaded artifacts for detailed results.**\n\n';
              }
            } catch (e) {
              console.log('Could not check test results:', e.message);
            }
          }
          
          comment += '### ðŸ“‹ Next Steps\n';
          comment += '1. Review the failure details above\n';
          comment += `2. Check the [full workflow logs](${context.payload.repository.html_url}/actions/runs/${context.runId}) for complete context\n`;
          comment += '3. Fix the issues and push new commits to update this PR\n';
          comment += '4. The CI will automatically run again on new commits\n\n';
          comment += '---\n';
          comment += '*This comment was automatically generated by the CI workflow when build/test failures were detected.*';
          
          // Post the comment
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });