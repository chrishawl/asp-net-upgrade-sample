name: .NET Framework CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  SOLUTION_FILE: aspnet-upgrade-sample.sln
  BUILD_CONFIGURATION: Release

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  build-and-test:
    runs-on: windows-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Setup NuGet
      uses: NuGet/setup-nuget@v2.0.0
      with:
        nuget-version: 'latest'

    - name: Restore NuGet packages
      run: |
        Write-Host "Restoring NuGet packages..."
        Write-Host "Solution file: ${{ env.SOLUTION_FILE }}"
        Write-Host "Current directory: $(Get-Location)"
        
        # Restore packages with verbose output
        nuget restore ${{ env.SOLUTION_FILE }} -PackagesDirectory packages -Verbosity detailed -NonInteractive
        
        if ($LASTEXITCODE -ne 0) {
          throw "NuGet restore failed with exit code $LASTEXITCODE"
        }
        
        # Verify packages directory was created
        if (!(Test-Path "packages")) {
          throw "Packages directory was not created after NuGet restore"
        }
        
        Write-Host "Packages directory contents:"
        Get-ChildItem -Path "packages" -Directory | ForEach-Object { Write-Host "  $($_.Name)" }
        
        # Verify critical packages were restored
        $criticalPackages = @(
          "packages\xunit.runner.console.2.4.1\tools\net452\xunit.console.exe",
          "packages\Microsoft.Net.Compilers.3.6.0\build\Microsoft.Net.Compilers.props"
        )
        
        foreach ($package in $criticalPackages) {
          if (!(Test-Path $package)) {
            Write-Host "‚ùå Critical package not found: $package"
            
            # Try to find alternative locations
            $packageName = Split-Path $package -Leaf
            Write-Host "Searching for $packageName in packages directory..."
            Get-ChildItem -Path "packages" -Recurse -Include $packageName -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  Found alternative: $($_.FullName)" }
            
            throw "Critical package not found: $package"
          } else {
            Write-Host "‚úÖ Verified package: $package"
          }
        }
        
        Write-Host "NuGet packages restored successfully!"
      shell: powershell

    - name: Build solution
      run: |
        Write-Host "Building solution..."
        Write-Host "Current directory: $(Get-Location)"
        Write-Host "Solution file: ${{ env.SOLUTION_FILE }}"
        
        # List all files to debug path issues
        Write-Host "Directory contents:"
        Get-ChildItem -Path . -Force | ForEach-Object { Write-Host "  $($_.Name)" }
        
        # Check if solution file exists
        if (!(Test-Path "${{ env.SOLUTION_FILE }}")) {
          throw "Solution file not found: ${{ env.SOLUTION_FILE }}"
        }
        
        # Build solution with detailed output
        Write-Host "Starting MSBuild..."
        msbuild ${{ env.SOLUTION_FILE }} /p:Configuration=${{ env.BUILD_CONFIGURATION }} /p:Platform="Any CPU" /verbosity:normal /flp:logfile=build.log;verbosity=diagnostic
        
        if ($LASTEXITCODE -ne 0) {
          Write-Host "Build failed. Checking for build log..."
          if (Test-Path "build.log") {
            Write-Host "Build log contents:"
            Get-Content "build.log" | ForEach-Object { Write-Host $_ }
          }
          throw "MSBuild failed with exit code $LASTEXITCODE"
        }
        
        Write-Host "Build completed successfully!"
        
        # List build outputs for debugging
        Write-Host "Build outputs:"
        Get-ChildItem -Path "tests\MVCRandomAnswerGenerator.Framework.Tests\bin" -Recurse -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  $($_.FullName)" }
        Get-ChildItem -Path "src\MVCRandomAnswerGenerator.Framework\MVCRandomAnswerGenerator\bin" -Recurse -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  $($_.FullName)" }
      shell: powershell

    - name: Create test results directory
      run: |
        if (!(Test-Path "TestResults")) { New-Item -ItemType Directory -Path "TestResults" }
      shell: powershell

    - name: Upload build logs
      uses: actions/upload-artifact@v4
      if: failure()
      with:
        name: build-logs
        path: |
          build.log
          *.log

    - name: Run tests
      run: |
        Write-Host "Test execution details:"
        $testDll = "tests\MVCRandomAnswerGenerator.Framework.Tests\bin\${{ env.BUILD_CONFIGURATION }}\MVCRandomAnswerGenerator.Framework.Tests.dll"
        $xunitRunner = ".\packages\xunit.runner.console.2.4.1\tools\net452\xunit.console.exe"
        
        Write-Host "Test DLL path: $testDll"
        Write-Host "xUnit runner path: $xunitRunner"
        Write-Host "Current directory: $(Get-Location)"
        
        # List directory contents for debugging
        Write-Host "=== Searching for Test Assembly ==="
        $testDir = "tests\MVCRandomAnswerGenerator.Framework.Tests\bin"
        if (Test-Path $testDir) {
          Write-Host "Test bin directory exists. Contents:"
          Get-ChildItem -Path $testDir -Recurse | ForEach-Object { Write-Host "  $($_.FullName)" }
        } else {
          Write-Host "Test bin directory does not exist: $testDir"
          Write-Host "Available directories in tests\MVCRandomAnswerGenerator.Framework.Tests\:"
          Get-ChildItem -Path "tests\MVCRandomAnswerGenerator.Framework.Tests\" -Directory -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  $($_.Name)" }
        }
        
        Write-Host "=== Searching for xUnit Runner ==="
        $packagesDir = ".\packages"
        if (Test-Path $packagesDir) {
          Write-Host "Packages directory exists. xUnit related contents:"
          Get-ChildItem -Path $packagesDir -Directory | Where-Object { $_.Name -like "*xunit*" } | ForEach-Object { 
            Write-Host "  Package: $($_.Name)"
            Get-ChildItem -Path $_.FullName -Recurse -Include "*.exe" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "    Executable: $($_.FullName)" }
          }
        } else {
          Write-Host "Packages directory does not exist: $packagesDir"
        }
        
        # Verify test assembly exists
        if (!(Test-Path $testDll)) {
          Write-Host "‚ùå Test assembly not found at: $testDll"
          
          # Try to find test DLLs anywhere
          Write-Host "Searching for test assemblies in entire repository..."
          Get-ChildItem -Path . -Recurse -Include "*Tests*.dll" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  Found: $($_.FullName)" }
          
          throw "Test assembly not found at: $testDll"
        } else {
          Write-Host "‚úÖ Test assembly found: $testDll"
        }
        
        # Verify xUnit runner exists
        if (!(Test-Path $xunitRunner)) {
          Write-Host "‚ùå xUnit console runner not found at: $xunitRunner"
          
          # Try to find xUnit console runners anywhere
          Write-Host "Searching for xUnit console runners in packages..."
          Get-ChildItem -Path . -Recurse -Include "xunit.console.exe" -ErrorAction SilentlyContinue | ForEach-Object { Write-Host "  Found: $($_.FullName)" }
          
          throw "xUnit console runner not found at: $xunitRunner"
        } else {
          Write-Host "‚úÖ xUnit runner found: $xunitRunner"
        }
        
        # Run tests with verbose output
        Write-Host "=== Running Tests ==="
        & $xunitRunner $testDll -xml TestResults\test-results.xml -verbose
        
        if ($LASTEXITCODE -ne 0) {
          throw "Tests failed with exit code $LASTEXITCODE"
        } else {
          Write-Host "All tests passed successfully!"
        }
      shell: powershell

    - name: Generate coverage report
      run: |
        Write-Host "Setting up code coverage..."
        
        # Install OpenCover for .NET Framework code coverage
        if (!(Test-Path "packages\OpenCover.4.7.1221\tools\OpenCover.Console.exe")) {
          Write-Host "Installing OpenCover package..."
          nuget install OpenCover -Version 4.7.1221 -OutputDirectory packages
        }
        
        # Install ReportGenerator for coverage reports
        if (!(Test-Path "packages\ReportGenerator.5.1.26\tools\net47\ReportGenerator.exe")) {
          Write-Host "Installing ReportGenerator package..."
          nuget install ReportGenerator -Version 5.1.26 -OutputDirectory packages
        }
        
        $openCover = ".\packages\OpenCover.4.7.1221\tools\OpenCover.Console.exe"
        $reportGenerator = ".\packages\ReportGenerator.5.1.26\tools\net47\ReportGenerator.exe"
        $testDll = "tests\MVCRandomAnswerGenerator.Framework.Tests\bin\${{ env.BUILD_CONFIGURATION }}\MVCRandomAnswerGenerator.Framework.Tests.dll"
        $xunitRunner = ".\packages\xunit.runner.console.2.4.1\tools\net452\xunit.console.exe"
        
        # Create coverage directory
        if (!(Test-Path "TestResults\Coverage")) { New-Item -ItemType Directory -Path "TestResults\Coverage" }
        
        # Run tests with code coverage
        Write-Host "Running tests with code coverage..."
        & $openCover `
          -target:$xunitRunner `
          -targetargs:"$testDll -xml TestResults\test-results-coverage.xml -noshadow" `
          -filter:"+[MVCRandomAnswerGenerator*]* -[*.Tests]*" `
          -output:"TestResults\Coverage\coverage.xml" `
          -register:user `
          -returntargetcode
        
        if ($LASTEXITCODE -ne 0) {
          Write-Warning "Code coverage collection encountered issues, but continuing..."
        }
        
        # Generate HTML coverage report
        if (Test-Path "TestResults\Coverage\coverage.xml") {
          Write-Host "Generating HTML coverage report..."
          & $reportGenerator `
            -reports:"TestResults\Coverage\coverage.xml" `
            -targetdir:"TestResults\Coverage\Html" `
            -reporttypes:"Html;Cobertura"
          
          if (Test-Path "TestResults\Coverage\Html\index.html") {
            Write-Host "Coverage report generated successfully!"
          } else {
            Write-Warning "HTML coverage report generation failed"
          }
        } else {
          Write-Warning "Coverage XML file not found, skipping HTML report generation"
        }
      shell: powershell

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: TestResults/

    - name: Upload coverage reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: coverage-report
        path: TestResults/Coverage/

    - name: Publish test results
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: .NET Framework Tests
        path: TestResults/test-results*.xml
        reporter: java-junit
        fail-on-error: true

    - name: Create deployment artifacts
      run: |
        Write-Host "Creating deployment artifacts..."
        
        # Create artifacts directory
        if (!(Test-Path "artifacts")) { New-Item -ItemType Directory -Path "artifacts" }
        
        # Copy built application files
        $sourcePath = "src\MVCRandomAnswerGenerator.Framework\MVCRandomAnswerGenerator"
        $artifactPath = "artifacts\MVCRandomAnswerGenerator.Framework"
        
        if (!(Test-Path $artifactPath)) { New-Item -ItemType Directory -Path $artifactPath -Force }
        
        # Copy application files (excluding source code, keeping only compiled output and content)
        $excludePatterns = @("*.cs", "*.csproj", "*.user", "obj", "Properties\AssemblyInfo.cs")
        
        Write-Host "Copying application files..."
        robocopy $sourcePath $artifactPath /E /XD obj /XF *.cs *.csproj *.user /NFL /NDL /NJH /NJS /NC /NS /NP
        
        # Copy bin directory specifically
        if (Test-Path "$sourcePath\bin\${{ env.BUILD_CONFIGURATION }}") {
          Write-Host "Copying bin files..."
          robocopy "$sourcePath\bin\${{ env.BUILD_CONFIGURATION }}" "$artifactPath\bin" /E /NFL /NDL /NJH /NJS /NC /NS /NP
        }
        
        # Create a simple deployment manifest
        $manifestContent = "{`"application`": `"MVCRandomAnswerGenerator.Framework`", `"version`": `"1.0.0`", `"buildConfiguration`": `"${{ env.BUILD_CONFIGURATION }}`", `"buildDate`": `"$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')`", `"gitCommit`": `"${{ github.sha }}`", `"gitBranch`": `"${{ github.ref_name }}`", `"framework`": `".NET Framework 4.7.2`"}"
        $manifestContent | Out-File -FilePath "artifacts\deployment-manifest.json" -Encoding UTF8
        
        # List contents for verification
        Write-Host "Deployment artifacts created:"
        Get-ChildItem -Path "artifacts" -Recurse | ForEach-Object { Write-Host "  $($_.FullName)" }
      shell: powershell

    - name: Upload deployment artifacts
      uses: actions/upload-artifact@v4
      with:
        name: deployment-artifacts
        path: artifacts/
        retention-days: 30

    - name: Comment on PR with build summary
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          let comment = '## ‚úÖ .NET Framework CI/CD Build Summary\n\n';
          comment += `**Workflow:** ${context.workflow}\n`;
          comment += `**Run:** [#${context.runNumber}](${context.payload.repository.html_url}/actions/runs/${context.runId})\n`;
          comment += `**Commit:** ${context.sha.substring(0, 7)}\n`;
          comment += `**Branch:** ${context.ref.replace('refs/heads/', '')}\n\n`;
          
          comment += '### üìä Build Results\n';
          comment += '- ‚úÖ NuGet packages restored successfully\n';
          comment += '- ‚úÖ Solution built successfully (.NET Framework 4.7.2)\n';
          comment += '- ‚úÖ Unit tests executed and passed\n';
          comment += '- ‚úÖ Code coverage collected\n';
          comment += '- ‚úÖ Deployment artifacts generated\n\n';
          
          comment += '### üì¶ Generated Artifacts\n';
          comment += '- **Test Results**: Unit test execution results and coverage reports\n';
          comment += '- **Coverage Report**: HTML code coverage analysis\n';
          comment += '- **Deployment Artifacts**: Ready-to-deploy application files\n\n';
          
          comment += '### üéØ Next Steps\n';
          comment += 'The .NET Framework application is ready for deployment. ';
          comment += 'All artifacts are available in the workflow run for download.\n\n';
          
          comment += '---\n';
          comment += '*This build summary was automatically generated by the .NET Framework CI/CD pipeline.*';
          
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });